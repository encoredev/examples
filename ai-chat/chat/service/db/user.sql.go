// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: user.sql

package db

import (
	"context"

	"encore.dev/types/uuid"
)

const getUser = `-- name: GetUser :one
SELECT id, provider, provider_id, name, profile, bot_id FROM "user" WHERE id = $1
`

func (q *Queries) GetUser(ctx context.Context, db DBTX, id uuid.UUID) (*User, error) {
	row := db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Profile,
		&i.BotID,
	)
	return &i, err
}

const insertUser = `-- name: InsertUser :one
INSERT INTO "user" (id, provider, provider_id, name, profile, bot_id) VALUES (gen_random_uuid(), $1, $2, $3, $4, $5) RETURNING id, provider, provider_id, name, profile, bot_id
`

type InsertUserParams struct {
	Provider   Provider
	ProviderID string
	Name       string
	Profile    string
	BotID      *uuid.UUID
}

func (q *Queries) InsertUser(ctx context.Context, db DBTX, arg InsertUserParams) (*User, error) {
	row := db.QueryRowContext(ctx, insertUser,
		arg.Provider,
		arg.ProviderID,
		arg.Name,
		arg.Profile,
		arg.BotID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Provider,
		&i.ProviderID,
		&i.Name,
		&i.Profile,
		&i.BotID,
	)
	return &i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, provider, provider_id, name, profile, bot_id FROM "user"
`

func (q *Queries) ListUsers(ctx context.Context, db DBTX) ([]*User, error) {
	rows, err := db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Name,
			&i.Profile,
			&i.BotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByProvider = `-- name: ListUsersByProvider :many
SELECT id, provider, provider_id, name, profile, bot_id FROM "user" WHERE provider = $1
`

func (q *Queries) ListUsersByProvider(ctx context.Context, db DBTX, provider Provider) ([]*User, error) {
	rows, err := db.QueryContext(ctx, listUsersByProvider, provider)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Name,
			&i.Profile,
			&i.BotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersInChannel = `-- name: ListUsersInChannel :many
WITH channel_users AS (
  SELECT distinct author_id FROM message WHERE channel_id = $1
)
SELECT id, provider, provider_id, name, profile, bot_id FROM "user" WHERE id IN (SELECT author_id FROM channel_users)
`

func (q *Queries) ListUsersInChannel(ctx context.Context, db DBTX, channelID uuid.UUID) ([]*User, error) {
	rows, err := db.QueryContext(ctx, listUsersInChannel, channelID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Provider,
			&i.ProviderID,
			&i.Name,
			&i.Profile,
			&i.BotID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
