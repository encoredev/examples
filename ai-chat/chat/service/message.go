package chat

import (
	"context"
	"database/sql"
	"slices"
	"time"

	"github.com/cockroachdb/errors"

	botsvc "encore.app/bot"
	botdb "encore.app/bot/db"
	"encore.app/chat/provider"
	"encore.app/chat/service/db"
	llmprovider "encore.app/llm/provider"
	"encore.app/llm/service"
	fns "encore.app/pkg/fns"
	"encore.dev/rlog"
	"encore.dev/types/uuid"
)

type InstructRequest struct {
	Bots        []db.BotID
	Instruction string
}

// InstructBotInProviderChannel looks up a channel by provider and channelID and calls InstructBotInChannel.
//
//encore:api public method=POST path=/chat/provider/:provider/channels/:channelID/instruct
func (svc *Service) InstructBotInProviderChannel(ctx context.Context, provider string, channelID string, req *InstructRequest) error {
	q := db.New()
	c, err := q.GetChannelByProviderID(ctx, chatdb.Stdlib(), db.GetChannelByProviderIDParams{
		ProviderID: channelID,
		Provider:   db.Provider(provider),
	})
	if err != nil {
		return errors.Wrap(err, "get channel")
	}
	return svc.InstructBotInChannel(ctx, c.ID, req)
}

// InstructBot sends an instruction to a bot in a channel. It publishes a task to the LLM provider which
// decides how to handle the instruction. It can be used to e.g. manually trigger a message from a bot.
// Instructions are not sent to the chat providers
//
//encore:api public method=POST path=/chat/channels/:channelID/instruct
func (svc *Service) InstructBotInChannel(ctx context.Context, channelID uuid.UUID, req *InstructRequest) error {
	q := db.New()
	_, err := q.InsertMessage(ctx, chatdb.Stdlib(), db.InsertMessageParams{
		ChannelID: channelID,
		AuthorID:  db.Admin.ID,
		Content:   req.Instruction,
		Timestamp: time.Now().UTC(),
	})
	if err != nil {
		return errors.Wrap(err, "insert message")
	}
	bots, err := botsvc.List(ctx, &botsvc.ListBotRequest{IDs: req.Bots})
	if err != nil {
		return errors.Wrap(err, "get bot")
	}
	channel, err := svc.GetChannel(ctx, channelID)
	if err != nil {
		return errors.Wrap(err, "get channel")
	}
	err = svc.publishLLMTasks(ctx, llmprovider.TaskTypeInstruct, bots.Bots, channel, req.Instruction)
	return errors.Wrap(err, "publish llm task")

}

// ProcessLLMMessage is the subscription handler for the llm-messages.
// It sends a message from a bot (generated by llm) to the chat provider.
// The message is inserted into the database by the channel message handler.
//
//encore:api private path=/chat/llm/message method=POST
func (svc *Service) ProcessLLMMessage(ctx context.Context, event *llmprovider.BotResponse) error {
	prov, ok := svc.providers[event.Channel.Provider]
	if !ok {
		return errors.New("provider not found")
	}
	botIDs := fns.Map(event.Messages, func(m *llmprovider.BotMessage) uuid.UUID { return m.Bot })
	bots, err := botsvc.List(ctx, &botsvc.ListBotRequest{IDs: botIDs})
	if err != nil {
		return errors.Wrap(err, "list bots")
	}
	botsByID := fns.ToMap(bots.Bots, func(b *botdb.Bot) uuid.UUID { return b.ID })
	pc := prov.GetChannelClient(ctx, event.Channel.ProviderID)
	for _, msg := range event.Messages {
		switch msg.Type {
		case llmprovider.BotMessageTypeTyping:
			err := pc.Typing(ctx, botsByID[msg.Bot].ID)
			if err != nil {
				rlog.Warn("send typing", "error", err)
			}
		default:
			err := pc.Send(ctx, &provider.SendMessageRequest{
				Content: msg.Content,
				Bot:     botsByID[msg.Bot],
				Type:    "message",
			})
			if err != nil {
				rlog.Warn("send message", "error", err)
			}
		}
	}
	if event.TaskType == llmprovider.TaskTypeLeave {
		for _, b := range botsByID {
			err := prov.GetChannelClient(ctx, event.Channel.ProviderID).Leave(ctx, b)
			if err != nil {
				return errors.Wrap(err, "leave channel")
			}
		}
	}
	return nil
}

// ProcessProviderEvent processes an event from a chat provider. It can be a message or a channel creation event.
//
//encore:api private path=/chat/events/provider method=POST
func (svc *Service) ProcessProviderEvent(ctx context.Context, event *provider.Message) error {
	switch event.Type {
	case "channel_created":
		return svc.ProcessProviderChannelCreated(ctx, event)
	default:
		return svc.ProcessProviderMessage(ctx, event)
	}
}

// ProcessProviderChannelCreated processes a channel creation event from a chat provider. It inserts the channel into the
// database and assigns two bots to the channel. It then sends a prepopulate task to the LLM provider to prepopulate the
// channel with messages.
//
//encore:api private path=/chat/events/provider/channel method=POST
func (svc *Service) ProcessProviderChannelCreated(ctx context.Context, msg *provider.Message) error {
	prov, ok := svc.providers[msg.Provider]
	if !ok {
		return errors.New("provider not found")
	}
	channel, err := svc.insertChannel(ctx, provider.ChannelInfo{
		Provider: msg.Provider,
		ID:       msg.ChannelID,
		Name:     msg.ChannelID,
	})
	if err != nil {
		return errors.Wrap(err, "insert channel")
	}
	resp, err := botsvc.List(ctx, &botsvc.ListBotRequest{})
	if err != nil {
		return errors.Wrap(err, "list bots")
	}
	bots := fns.SelectRandom(resp.Bots, 2)
	q := db.New()
	for _, b := range bots {
		_, err = q.UpsertBotChannel(ctx, chatdb.Stdlib(), db.UpsertBotChannelParams{
			Bot:      b.ID,
			Channel:  channel.ID,
			Provider: msg.Provider,
		})
		if err != nil {
			return errors.Wrap(err, "upsert botID channel")
		}
		err := prov.GetChannelClient(ctx, msg.ChannelID).Join(ctx, b)
		if err != nil {
			return errors.Wrap(err, "join channel")
		}
	}
	return svc.publishLLMTasks(ctx, llmprovider.TaskTypePrepopulate, bots, channel, "")
}

// ProcessProviderMessage processes an inbound message from a chat provider. It inserts the message into the database
// and sends it to the LLM provider to handle the message.
//
//encore:api private path=/chat/events/provider/message method=POST
func (svc *Service) ProcessProviderMessage(ctx context.Context, msg *provider.Message) error {
	msgs, err := svc.handleProviderMessages(ctx, msg.Provider, msg)
	if err != nil {
		return errors.Wrap(err, "handle provider messages")
	}
	if len(msgs) == 0 {
		return nil
	}
	q := db.New()
	author, err := q.GetUser(ctx, chatdb.Stdlib(), msgs[0].AuthorID)
	if err != nil {
		return errors.Wrap(err, "get user")
	}
	if author.BotID != nil {
		return nil
	}
	botIDs, err := q.ListBotsInChannel(ctx, chatdb.Stdlib(), msgs[0].ChannelID)
	if err != nil {
		return errors.Wrap(err, "list bots in channel")
	}
	if len(botIDs) == 0 {
		return nil
	}
	bots, err := botsvc.List(ctx, &botsvc.ListBotRequest{IDs: botIDs})
	if err != nil {
		return errors.Wrap(err, "list bots")
	}
	channel, err := svc.GetChannel(ctx, msgs[0].ChannelID)
	if err != nil {
		return errors.Wrap(err, "get channel")
	}
	err = svc.publishLLMTasks(ctx, llmprovider.TaskTypeContinue, bots.Bots, channel, "")
	return errors.Wrap(err, "publish llm task")
}

// publishLLMTasks send tasks to the LLM provider to handle a specific event in a channel. It sends the task to all
// providers that have bots in the channel.
func (svc *Service) publishLLMTasks(ctx context.Context, typ llmprovider.TaskType, bots []*botdb.Bot, channel *db.Channel, adminPrompt string) error {
	msgs, err := svc.getChannelHistory(ctx, channel.ID)
	if err != nil {
		return errors.Wrap(err, "get channel history")
	}
	users, err := svc.getChannelUsers(ctx, channel.ID)
	if err != nil {
		return errors.Wrap(err, "get channel users")
	}

	botsByProvider := make(map[string][]*botdb.Bot)
	for _, b := range bots {
		botsByProvider[b.Provider] = append(botsByProvider[b.Provider], b)
	}
	for prov, bots := range botsByProvider {
		_, err := llm.TaskTopic.Publish(ctx, &llmprovider.ChatRequest{
			Bots:      bots,
			Users:     users,
			Channel:   channel,
			Messages:  msgs,
			SystemMsg: adminPrompt,
			Provider:  prov,
			Type:      typ,
		},
		)
		if err != nil {
			rlog.Warn("publish llm task", "error", err)
		}
	}
	return nil
}

// loadChannelHistory loads the message history for a channel from the provider and inserts it into the database.
// It retrieves the latest message from the database and fetches all messages from the provider that are newer.
func (svc *Service) loadChannelHistory(ctx context.Context, channel *db.Channel) ([]*db.Message, error) {
	queries := db.New()
	msg, err := queries.LatestMessageInChannel(ctx, chatdb.Stdlib(), channel.ID)
	if !errors.Is(err, sql.ErrNoRows) && err != nil {
		return nil, errors.Wrap(err, "latest message in channel")
	}
	prov, ok := svc.providers[channel.Provider]
	if !ok {
		return nil, errors.New("provider not found")
	}
	messages, err := prov.GetChannelClient(ctx, channel.ProviderID).ListMessages(ctx, msg)
	if err != nil {
		return nil, errors.Wrap(err, "list messages")
	}
	return svc.handleProviderMessages(ctx, channel.Provider, messages...)
}

// handleProviderMessages inserts messages, authors and channels from a provider into the database.
// It's used when loading the history of a channel or when processing inbound messages.
func (svc *Service) handleProviderMessages(ctx context.Context, providerName db.Provider, messages ...*provider.Message) ([]*db.Message, error) {
	q := db.New()
	prov, ok := svc.providers[providerName]
	if !ok {
		return nil, errors.New("provider not found")
	}
	users, err := q.ListUsersByProvider(ctx, chatdb.Stdlib(), providerName)
	if err != nil {
		return nil, errors.Wrap(err, "list users by provider")
	}
	userByID := fns.ToMap(users, func(u *db.User) provider.UserID { return u.ProviderID })
	channels, err := q.ListChannelsByProvider(ctx, chatdb.Stdlib(), providerName)
	if err != nil {
		return nil, errors.Wrap(err, "list channels by provider")
	}
	channelByID := fns.ToMap(channels, func(c *db.Channel) provider.ChannelID { return c.ProviderID })

	var insertedMessages []*db.Message
	for _, msg := range messages {
		author, ok := userByID[msg.Author.ID]
		if !ok {
			params := db.InsertUserParams{
				Provider:   providerName,
				ProviderID: msg.Author.ID,
				Name:       msg.Author.Name,
			}
			if msg.Author.BotID != uuid.Nil {
				params.BotID = &msg.Author.BotID
			} else {
				user, err := prov.GetUser(ctx, msg.Author.ID)
				if err != nil {
					return nil, errors.Wrap(err, "get user")
				}
				if user != nil {
					params.Profile = user.Profile
					params.Name = user.Name
				}
			}
			author, err = q.InsertUser(ctx, chatdb.Stdlib(), params)
			if err != nil {
				return nil, errors.Wrap(err, "insert user")
			}
			userByID[msg.Author.ID] = author
		}
		channel, ok := channelByID[msg.ChannelID]
		if !ok {
			cInfo, err := prov.GetChannelClient(ctx, msg.ChannelID).Info(ctx)
			if err != nil {
				return nil, errors.Wrap(err, "get channel info")
			}
			channel, err = svc.insertChannel(ctx, cInfo)
			if err != nil {
				return nil, errors.Wrap(err, "insert channel")
			}
		}
		dbMsg, err := q.InsertMessage(ctx, chatdb.Stdlib(), db.InsertMessageParams{
			ChannelID:  channel.ID,
			AuthorID:   author.ID,
			Content:    msg.Content,
			Timestamp:  msg.Time,
			ProviderID: msg.ProviderID,
		})
		if errors.Is(err, sql.ErrNoRows) {
			continue
		} else if err != nil {
			return nil, errors.Wrap(err, "insert message")
		}
		insertedMessages = append(insertedMessages, dbMsg)
	}
	return insertedMessages, nil
}

// getChannelHistory returns the message history for a channel. It doesn't fetch the messages from the provider,
// but rather from the database.
func (svc *Service) getChannelHistory(ctx context.Context, channelID db.ChannelID) ([]*db.Message, error) {
	queries := db.New()
	msgs, err := queries.ListMessagesInChannel(ctx, chatdb.Stdlib(), channelID)
	if err != nil {
		return nil, errors.Wrap(err, "list messages by channel")
	}
	// We fetch the messages in reverse order to get the latest messages, so we need to reverse them back
	slices.Reverse(msgs)
	return msgs, nil
}

// getChannelUsers returns the users in a channel. It always includes the admin user which is used to instruct the bot
// when sending commands to the LLM providers
func (svc *Service) getChannelUsers(ctx context.Context, channelID db.ChannelID) ([]*db.User, error) {
	queries := db.New()
	users, err := queries.ListUsersInChannel(ctx, chatdb.Stdlib(), channelID)
	if err != nil {
		return nil, errors.Wrap(err, "list users by channel")
	}
	// Admin has to be included to ensure the bot can be instructed
	users = append(users, db.Admin)
	return users, nil
}
